<h1 id="portable-mustache-templating-implementation-in-r7rs">Portable mustache templating implementation in R7RS</h1>
<p>This library implements version 1.2.1 of the mustache spec. Implementation passes all tests in the spec.</p>
<p>This readme only describes specifics of this implementation. For general semantics, see https://mustache.github.io/mustache.5.html</p>
<h2 id="base-usage">Base usage</h2>
<p><code>(import (arvyy mustache))</code></p>
<p>First, templates need to be compiled, using one of following ways.</p>
<ul>
<li><code>(compile root partial-locator)</code>. Here <code>root</code> should be a string of the “root” partial which will be the entry point during execution. <code>partial-locator</code> must be a procedure, that accepts partial’s name as a single argument, and returns either #f if it cannot be found, or string or textual input port.</li>
</ul>
<pre><code>(define (locator name)
  (cond
    ((string=? name &quot;root&quot;) &quot;Hello {{&gt;foo}}&quot;)
    ((string=? name &quot;foo&quot;) &quot;{{world}}&quot;)
    (else #f))
(define hello-world-compiled (compile &quot;root&quot; locator))</code></pre>
<ul>
<li><code>(compile template)</code>. Compiles given template string.</li>
</ul>
<pre><code>(define hello-world-compiled (compile &quot;Hello {{world}}&quot;))</code></pre>
<p>Compiled template can be executed using</p>
<ul>
<li><code>(execute compilation data out)</code>. <code>compilation</code> is result of <code>compile</code> invokation; <code>data</code> is the root object for interpolations; <code>out</code> is a textual output port, to which result will be writen. Returns unspecified value</li>
</ul>
<pre><code>(call-with-output-file &quot;result.txt&quot; 
                       (lambda (out) 
                         (execute hello-world-compiled
                                  &#39;((world . &quot;Scheme&quot;))
                                   out)))</code></pre>
<ul>
<li><code>(execute compilation data)</code>. Instead of writing to a port, returns interpolated string result as a function value.</li>
</ul>
<pre><code>(display (execute hello-world-compiled &#39;((world . &quot;Scheme&quot;))))</code></pre>
<p>By default, vectors and streams are accepted for list interpolation, alists for object field lookup, data values are writen as with <code>display</code>.</p>
<h2 id="behavior-customization">Behavior customization</h2>
<p>Behavior can be altered by use of parameterization.</p>
<h3 id="field-lookup-in-object">Field lookup in object</h3>
<p>Lookup is a procedure, that finds corresponding value given an object and a fragment (fragment being elements of list after splitting tag name by <code>.</code>), of the following form</p>
<p><code>(lookup object name found not-found)</code>. Object is currently examined datum; name is a fragment / field of string type; found is a function that should be invoked in tail position if field was found in the object with corresponding value as an argument; not-found is a 0 argument function that should be invoked in tail position if field was not found in the object, or if the object cannot be inspected with this lookup function.</p>
<p>For example, creating a lookup for a record type:</p>
<pre><code>(define-record-type &lt;foo&gt; (foo bar) foo? (bar foo-bar))
(define (foo-lookup obj name found not-found)
  (cond
    ((not (foo? obj)) (not-found))
    ((string=? &quot;bar&quot; name) (found (foo-bar obj)))
    (else (not-found))))</code></pre>
<p>Use <code>compose-lookups</code> to merge multiple lookup implementations into one:</p>
<pre><code>(define alist+foo (compose-lookups alist-lookup foo-lookup))</code></pre>
<p>When composed, each lookup is tried to be applied to the object until one of lookups invokes <code>found</code>, in given order. If all lookups return not-found, then composition also returns not-found</p>
<p>The lookup used during execution is retrieved from <code>current-lookup</code> parameter. It defaults to <code>alist-lookup</code>.</p>
<h3 id="collection">Collection</h3>
<p>Collection is a reference to a set of methods of an iterable multivalue object type, which is used to expand sections. Collection is created with</p>
<p><code>(collection pred?-proc empty?-proc for-each-proc)</code> where <code>pred?-proc</code> is a predicate for given collection, <code>empty?-proc</code> is procedure returning if given collection is empty, <code>for-each-proc</code> is a procedure that given a one argument function and this collection, executes given function for each element.</p>
<pre><code>(define list-collection (collection list? null? for-each))</code></pre>
<p>Use <code>compose-collections</code> to merge multiple collections into one</p>
<pre><code>(define vec+list (compose-collections vector-collection list-collection))</code></pre>
<p>The collection used during execution is retrieved from <code>current-collection</code> parameter. It defaults to <code>(compose-collections vector-collection stream-collection)</code>. While the library does export <code>list-collection</code>, it is not used by default as to not clash with alist lookup for objects.</p>
<h3 id="value-writing">Value writing</h3>
<p>Writer is a procedure of form</p>
<p><code>(writer obj out)</code> where obj is a scheme object, and out is textual output port. Writer should write appropriate representation of obj to out.</p>
<p>The writer used during execution is retrieved from <code>current-writer</code> parameter. It defaults to <code>(lambda (obj out) (when obj (display obj out)))</code>.</p>
