;;;; srfi-1.import.scm - GENERATED BY CHICKEN 5.4.0 -*- Scheme -*-

(##sys#with-environment
  (lambda ()
    (scheme#eval
      '(import-syntax
         (only r7rs
               begin
               cond-expand
               export
               import
               import-for-syntax
               include
               include-ci
               syntax-rules)
         scheme.base
         scheme.cxr
         srfi-8))
    (import
      (only r7rs
            begin
            cond-expand
            export
            import
            import-for-syntax
            include
            include-ci
            syntax-rules))
    (##sys#register-compiled-module
      'srfi-1
      'srfi-1
      (scheme#list
        '(%lset2<= . srfi-1#%lset2<=)
        '(really-append-map . srfi-1#really-append-map)
        '(%cars+cdrs/no-test . srfi-1#%cars+cdrs/no-test)
        '(%cars+cdrs+ . srfi-1#%cars+cdrs+)
        '(%cars+cdrs . srfi-1#%cars+cdrs)
        '(%cars+ . srfi-1#%cars+)
        '(%cdrs . srfi-1#%cdrs)
        '(optional . srfi-1#optional)
        '(check-arg . srfi-1#check-arg))
      '((xcons . srfi-1#xcons)
        (cons* . srfi-1#cons*)
        (list-tabulate . srfi-1#list-tabulate)
        (circular-list . srfi-1#circular-list)
        (iota . srfi-1#iota)
        (proper-list? . srfi-1#proper-list?)
        (circular-list? . srfi-1#circular-list?)
        (dotted-list? . srfi-1#dotted-list?)
        (not-pair? . srfi-1#not-pair?)
        (null-list? . srfi-1#null-list?)
        (list= . srfi-1#list=)
        (cadar . scheme#cadar)
        (caddr . scheme#caddr)
        (cdadr . scheme#cdadr)
        (cddar . scheme#cddar)
        (caaaar . scheme#caaaar)
        (caaadr . scheme#caaadr)
        (caadar . scheme#caadar)
        (caaddr . scheme#caaddr)
        (cadaar . scheme#cadaar)
        (cadadr . scheme#cadadr)
        (caddar . scheme#caddar)
        (cadddr . scheme#cadddr)
        (cdaaar . scheme#cdaaar)
        (cdaadr . scheme#cdaadr)
        (cdadar . scheme#cdadar)
        (cdaddr . scheme#cdaddr)
        (cddaar . scheme#cddaar)
        (cddadr . scheme#cddadr)
        (cdddar . scheme#cdddar)
        (cddddr . scheme#cddddr)
        (first . srfi-1#first)
        (second . srfi-1#second)
        (third . srfi-1#third)
        (fourth . srfi-1#fourth)
        (fifth . srfi-1#fifth)
        (sixth . srfi-1#sixth)
        (seventh . srfi-1#seventh)
        (eighth . srfi-1#eighth)
        (ninth . srfi-1#ninth)
        (tenth . srfi-1#tenth)
        (car+cdr . srfi-1#car+cdr)
        (take . srfi-1#take)
        (drop . srfi-1#drop)
        (take-right . srfi-1#take-right)
        (drop-right . srfi-1#drop-right)
        (take! . srfi-1#take!)
        (drop-right! . srfi-1#drop-right!)
        (split-at . srfi-1#split-at)
        (split-at! . srfi-1#split-at!)
        (last . srfi-1#last)
        (last-pair . srfi-1#last-pair)
        (length+ . srfi-1#length+)
        (concatenate . srfi-1#concatenate)
        (append! . srfi-1#append!)
        (concatenate! . srfi-1#concatenate!)
        (reverse! . srfi-1#reverse!)
        (append-reverse . srfi-1#append-reverse)
        (append-reverse! . srfi-1#append-reverse!)
        (zip . srfi-1#zip)
        (unzip1 . srfi-1#unzip1)
        (unzip2 . srfi-1#unzip2)
        (unzip3 . srfi-1#unzip3)
        (unzip4 . srfi-1#unzip4)
        (unzip5 . srfi-1#unzip5)
        (count . srfi-1#count)
        (fold . srfi-1#fold)
        (unfold . srfi-1#unfold)
        (pair-fold . srfi-1#pair-fold)
        (reduce . srfi-1#reduce)
        (fold-right . srfi-1#fold-right)
        (unfold-right . srfi-1#unfold-right)
        (pair-fold-right . srfi-1#pair-fold-right)
        (reduce-right . srfi-1#reduce-right)
        (append-map . srfi-1#append-map)
        (append-map! . srfi-1#append-map!)
        (map! . srfi-1#map!)
        (pair-for-each . srfi-1#pair-for-each)
        (filter-map . srfi-1#filter-map)
        (map-in-order . srfi-1#map-in-order)
        (filter . srfi-1#filter)
        (partition . srfi-1#partition)
        (remove . srfi-1#remove)
        (filter! . srfi-1#filter!)
        (partition! . srfi-1#partition!)
        (remove! . srfi-1#remove!)
        (find . srfi-1#find)
        (find-tail . srfi-1#find-tail)
        (any . srfi-1#any)
        (every . srfi-1#every)
        (list-index . srfi-1#list-index)
        (take-while . srfi-1#take-while)
        (drop-while . srfi-1#drop-while)
        (take-while! . srfi-1#take-while!)
        (span . srfi-1#span)
        (break . srfi-1#break)
        (span! . srfi-1#span!)
        (break! . srfi-1#break!)
        (delete . srfi-1#delete)
        (delete-duplicates . srfi-1#delete-duplicates)
        (delete! . srfi-1#delete!)
        (delete-duplicates! . srfi-1#delete-duplicates!)
        (alist-cons . srfi-1#alist-cons)
        (alist-copy . srfi-1#alist-copy)
        (alist-delete . srfi-1#alist-delete)
        (alist-delete! . srfi-1#alist-delete!)
        (lset<= . srfi-1#lset<=)
        (lset= . srfi-1#lset=)
        (lset-adjoin . srfi-1#lset-adjoin)
        (lset-union . srfi-1#lset-union)
        (lset-union! . srfi-1#lset-union!)
        (lset-intersection . srfi-1#lset-intersection)
        (lset-intersection! . srfi-1#lset-intersection!)
        (lset-difference . srfi-1#lset-difference)
        (lset-difference! . srfi-1#lset-difference!)
        (lset-xor . srfi-1#lset-xor)
        (lset-xor! . srfi-1#lset-xor!)
        (lset-diff+intersection . srfi-1#lset-diff+intersection)
        (lset-diff+intersection! . srfi-1#lset-diff+intersection!))
      (scheme#list
        (scheme#cons
          '|\x04r7rssrfi-1|
          (##sys#er-transformer (##core#lambda (x r c) (##core#undefined)))))
      (scheme#list
        (scheme#cons
          'internal-let-optionals
          (syntax-rules
            ()
            ((internal-let-optionals
               arg
               (((var ...) xparser) opt-clause ...)
               body
               ...)
             (call-with-values
               (lambda () (xparser arg))
               (lambda (rest var ...)
                 (internal-let-optionals rest (opt-clause ...) body ...))))
            ((internal-let-optionals
               arg
               ((var default) opt-clause ...)
               body
               ...)
             (call-with-values
               (lambda ()
                 (if (null? arg)
                   (values default '())
                   (values (car arg) (cdr arg))))
               (lambda (var rest)
                 (internal-let-optionals rest (opt-clause ...) body ...))))
            ((internal-let-optionals
               arg
               ((var default test) opt-clause ...)
               body
               ...)
             (call-with-values
               (lambda ()
                 (if (null? arg)
                   (values default '())
                   (let ((var (car arg)))
                     (if test
                       (values var (cdr arg))
                       (error "arg failed LET-OPT test" var)))))
               (lambda (var rest)
                 (internal-let-optionals rest (opt-clause ...) body ...))))
            ((internal-let-optionals
               arg
               ((var default test supplied?) opt-clause ...)
               body
               ...)
             (call-with-values
               (lambda ()
                 (if (null? arg)
                   (values default #f '())
                   (let ((var (car arg)))
                     (if test
                       (values var #t (cdr arg))
                       (error "arg failed LET-OPT test" var)))))
               (lambda (var supplied? rest)
                 (internal-let-optionals rest (opt-clause ...) body ...))))
            ((internal-let-optionals arg (rest) body ...)
             (let ((rest arg)) body ...))
            ((internal-let-optionals arg () body ...)
             (if (null? arg)
               (begin body ...)
               (error "Too many arguments in let-opt" arg)))))
        (scheme#cons
          'let-optionals
          (syntax-rules
            ()
            ((let-optionals arg (opt-clause ...) body ...)
             (let ((rest arg))
               (internal-let-optionals rest (opt-clause ...) body ...))))))
      (scheme#list))))

;; END OF FILE
